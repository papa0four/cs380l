diff -ruN aos_pintos/src/lib/kernel/list.c pintos-solution/src/lib/kernel/list.c
--- aos_pintos/src/lib/kernel/list.c	2024-01-30 21:43:54.000000000 +0000
+++ pintos-solution/src/lib/kernel/list.c	2024-02-03 06:11:06.899852268 +0000
@@ -1,5 +1,6 @@
 #include "list.h"
 #include "../debug.h"
+#include "../../threads/thread.h"
 
 /* Our doubly linked lists have two header elements: the "head"
    just before the first element and the "tail" just after the
@@ -31,8 +32,11 @@
    elements allows us to do a little bit of checking on some
    operations, which can be valuable.) */
 
+int get_sorted_index(struct list *threads, struct thread *target);
+bool comparator (const struct list_elem * a, const struct list_elem * b, void * aux);
+bool thread_less(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED);
 static bool is_sorted (struct list_elem *a, struct list_elem *b,
-                       list_less_func *less, void *aux) UNUSED;
+                       list_less_func *less, void *aux);
 
 /* Returns true if ELEM is a head, false otherwise. */
 static inline bool is_head (struct list_elem *elem)
@@ -311,13 +315,6 @@
     }
 }
 
-int get_sorted_index (struct list *threads, struct thread *target) {
-  /* Your implementation here */
-  (void) threads;
-  (void) target;
-  return 0;
-}
-
 /* Returns true only if the list elements A through B (exclusive)
    are in order according to LESS given auxiliary data AUX. */
 static bool is_sorted (struct list_elem *a, struct list_elem *b,
@@ -347,7 +344,8 @@
   do
     {
       a = list_next (a);
-  } while (a != b && !less (a, list_prev (a), aux));
+    }
+  while (a != b && !less (a, list_prev (a), aux));
   return a;
 }
 
@@ -411,7 +409,8 @@
           /* Merge the runs. */
           inplace_merge (a0, a1b0, b1, less, aux);
         }
-  } while (output_run_cnt > 1);
+    }
+  while (output_run_cnt > 1);
 
   ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
 }
@@ -495,3 +494,47 @@
     }
   return min;
 }
+
+bool comparator (const struct list_elem * a, const struct list_elem * b, void * aux)
+{
+    if ((NULL == a) ||
+        (NULL == b) ||
+        (NULL == aux))
+    {
+        return false;
+    }
+
+    struct thread * p_thread_a = list_entry(a, struct thread, allelem);
+    struct thread * p_thread_b = list_entry(b, struct thread, allelem);
+    return p_thread_a->tid < p_thread_b->tid;
+}
+
+int get_sorted_index (struct list * threads, struct thread * target)
+{
+    if ((NULL == threads) ||
+        (NULL == target))
+    {
+        return -1;
+    }
+
+    struct list_elem * p_entry = list_begin(threads);
+    struct thread * p_head = list_entry(p_entry, struct thread, allelem);
+
+    list_sort(threads, comparator, &p_head->tid);
+
+    int index = 0;
+    struct list_elem * p_elem = NULL;
+
+    for (p_elem = list_begin(threads); list_end(threads) != p_elem; p_elem = list_next(p_elem))
+    {
+        struct thread * p_current = list_entry(p_elem, struct thread, allelem);
+        if (target->tid == p_current->tid)
+        {
+            return index;
+        }
+
+        index++;
+    }
+
+    return -1;
+}
\ No newline at end of file
